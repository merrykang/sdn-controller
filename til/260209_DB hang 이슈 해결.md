### 오류 내용

`HikariCP - Apparent connection leak detected`
- HikariCP가 DB 커넥션을 빌려줬는데
- 설정된 leakDetectionThreshold 시간 이상
- 반납(close)되지 않은 커넥션이 있다고 판단
- 이건 항상 코드 버그를 의미하지는 않는다.

`LocalDataSourceJobStore
QuartzScheduler.rescheduleJob
BackupSchedulerService.init`
- 위 내용은 스프링 빌드 + Quartz 초기화 시 발생한 로그
- Quartz가 DB에서 Job/Trigger 조회 & 갱신
-	이 과정에서 커넥션을 획득함
- 즉 DB 는 살아있지만 응답을 못 하는 상태. 즉 커넥션은 가능하지만 커밋까지 도달하지 못 함

---

### 조치 내용
- 디스크 용량 문제도  있었음. 따라서 필요없는 파일, 폴더 삭제하고 총 20-30GB 용량 만듦.
그러나 그 후에도 여전히 위 문제 발생함

---

### 오류 원인
- 디스크 용량 부족으로 이미 DB 상태가 깨졌기 떄문임. 한 번 깨진 DB 는 오류 원인이 제거된다고 해서 자동 복구되지 않는다. 즉 디스크를 늘려도 이미 잡혀 있던 세션, 이미 멈춰버린 쿼리는 그대로 유지
- 디스크 용량 부족 시점에 아래 항목들이 엉켜서 존재함
	•	열린 트랜잭션
	•	임시 테이블
	•	redo / undo 로그
	•	내부 락

---

### 해결 방법
- DB 재기동했더니 해결됨.
- 해결된 이유: DB 재기동했더니 아래 사항들이 해결되어서 그럼
	•	모든 커넥션 강제 종료
	•	미완료 트랜잭션 rollback
	•	InnoDB crash recovery 수행
	•	내부 락, 대기 세션 초기화
	•	디스크 여유 공간에서 정상 재기동
  👉 그래서
    •	Quartz 초기화 쿼리가 즉시 종료
    •	커넥션 정상 반납
    •	Hikari leak 경고 사라짐
    •	웹서버 정상 기동
- 향후 수행해야할 완전 해결 방법
✅ 1. 디스크 용량 모니터링 (가장 중요)
	•	/var/lib/mysql 사용률 알람
	•	80% / 85% / 90% 단계별 알림
	•	로그 파티션 분리 권장

✅ 2. HikariCP 타임아웃 설정
spring.datasource.hikari:
connection-timeout: 30000
validation-timeout: 5000
max-lifetime: 1800000
leak-detection-threshold: 20000
👉 무한 대기 방지

✅ 3. Quartz 초기화 시점 방어
	•	@PostConstruct에서 DB 의존 로직 최소화
	•	DB 장애 시 재시도 구조
	•	앱 기동 실패 vs 기능 비활성화 분리

✅ 4. DB 장애 시 Runbook
“디스크 full → 용량 확보 → DB 재기동 여부 판단”

---

### 참고 사항
- 이건 커넥션 누수가 아니다
![커넥션 누수와 이번 이슈 비교](/images/connection_leak.jpg)