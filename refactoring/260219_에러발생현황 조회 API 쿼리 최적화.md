#### 기존 코드
```sql
@Query(value = "SELECT " + "  DATE(`timestamp`) AS alarmDate, " + "  category, " + "  COUNT(*) AS cnt, "
        + "  level " + "FROM ui_alarm " + "WHERE " + "  school_mark IN :schoolMarks "
        + "  AND category IN :categories " + "  AND ( " + "    DATE(`timestamp`) = DATE(:date1) "
        + "    OR DATE(`timestamp`) = DATE(:date2) " + "  ) " + "GROUP BY alarmDate, category, level "
        + "ORDER BY alarmDate", nativeQuery = true)
List<CategoryCountProjection> countAlarmBySchoolNameAndCategoryAndDate(
        @Param("schoolMarks") Set<String> schoolMarks, @Param("categories") Set<String> categories,
        @Param("date1") LocalDate date1, @Param("date2") LocalDate date2);

@Query(value = "SELECT " + "  DATE(`timestamp`) AS alarmDate, " + "  category, " + "  COUNT(*) AS cnt, "
        + "  level " + "FROM ui_alarm " + "WHERE " + "  category IN :categories " + "  AND ( "
        + "    DATE(`timestamp`) = DATE(:date1) " + "    OR DATE(`timestamp`) = DATE(:date2) " + "  ) "
        + "GROUP BY alarmDate, category, level " + "ORDER BY alarmDate", nativeQuery = true)
List<CategoryCountProjection> countAlarmBySchoolNameAndCategoryAndDateByManager(
        @Param("categories") Set<String> categories, @Param("date1") LocalDate date1,
        @Param("date2") LocalDate date2);
```
---

#### 수정 코드 및 이유

**1. DATE(컬럼) 조건 — 인덱스 미사용(Full Table Scan)**

- 인덱스는 컬럼의 **원본 값** 기준으로 정렬되어 있다. `WHERE DATE(timestamp) = :date`처럼 **컬럼에 함수를 씌우면** 옵티마이저는 인덱스를 타지 못하고, 매 행마다 `DATE(timestamp)`를 계산한 뒤 비교해야 하므로 **Full Table Scan**이 발생한다.
- 이런 조건을 **non-sargable**하다고 한다. 반대로 `timestamp >= :start AND timestamp < :end`처럼 컬럼을 그대로 비교하는 범위 조건은 **sargable**하여 `timestamp` 인덱스를 사용할 수 있다.
        - SARGable = Search ARGument able : 인덱스를 사용하여 빠르게 검색할 수 있는 조건

**2. OR 조건 — 인덱스 활용 저하**

- `DATE(timestamp) = :date1 OR DATE(timestamp) = :date2`처럼 같은 컬럼에 OR가 걸리면, 위와 결합되어 어차피 인덱스 사용이 어렵고, 가능하더라도 Index Merge 등으로 비용이 늘어날 수 있다.
- 날짜 두 구간을 **범위 조건 두 개**로 나누고, 각각 인덱스로 스캔한 뒤 **UNION ALL**로 합치면, 구간마다 Index Range Scan이 가능해진다.

**3. 수정 전략 요약**

- **파라미터**: `LocalDate date1, date2` 대신 `LocalDateTime start1, end1, start2, end2`를 사용한다.  
  - 예: date1 → start1 = date1 00:00:00, end1 = date1+1일 00:00:00 (미만).
- **조건**: `DATE(timestamp) = :date` 대신 `timestamp >= :start AND timestamp < :end`로 바꿔 sargable하게 만든다.
- **OR 제거**: 두 날짜 구간을 서브쿼리 두 개로 나누고 `UNION ALL`로 합친 뒤, 바깥에서 `GROUP BY alarmDate, category, level`로 집계한다.

```sql
@Query(value = "SELECT alarmDate, category, COUNT(*) AS cnt, level FROM ( "
        + "SELECT DATE(log_timestamp) AS alarmDate, category, level FROM ui_alarm "
        + "WHERE category IN (:categories) "
        + "AND log_timestamp >= :start1 AND log_timestamp < :end1 "
        + "UNION ALL "
        + "SELECT DATE(log_timestamp) AS alarmDate, category, level FROM ui_alarm "
        + "WHERE category IN (:categories) "
        + "AND log_timestamp >= :start2 AND log_timestamp < :end2 "
        + ") t GROUP BY alarmDate, category, level ORDER BY alarmDate", nativeQuery = true)
List<CategoryCountProjection> countAlarmBySchoolNameAndCategoryAndDateByManager(
        @Param("categories") Set<String> categories,
        @Param("start1") LocalDateTime start1, @Param("end1") LocalDateTime end1,
        @Param("start2") LocalDateTime start2, @Param("end2") LocalDateTime end2);
```
