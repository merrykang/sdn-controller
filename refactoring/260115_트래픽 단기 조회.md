### 문제 상황
- 최대 6일 조회 시에는 중간 테이블을 사용하지 않고 기존의 트래픽 누적 테이블을 사용함. 그러나 최근 24시간 트래픽 조회 시부터 타임아웃 에러 발생
- 즉 타임아웃 발생하여 데이터 조회를 하지 못 하고 터짐 
- 따라서 아래의 변경 전 쿼리를 최적화 해보고자 함

### 변경 전
```java
// 서비스 로직
// Raw 데이터 조회 
List<Object[]> rows = swConfPortsStatCRepository.findTrafficRawRows(schoolMarks, startDts.format(formatter), endDts.format(formatter)); 
// slotIndex → 누적 구조 
Map<Long, TrafficSlotAgg> slotAggMap = new HashMap<>(); 
for (Object[] row : rows) { 
  Timestamp ts = (Timestamp) row[0]; 
  float inputBps = row[1] != null ? ((Number) row[1]).floatValue() : 0f; 
  float outputBps = row[2] != null ? ((Number) row[2]).floatValue() : 0f; 
  long tsUnix = ts.toInstant().getEpochSecond(); 
  long slotIndex = (tsUnix - startUnix) / intervalSecond;
  if (slotIndex < 0 || slotIndex >= totalSlots) { continue; } 
  TrafficSlotAgg agg = slotAggMap.computeIfAbsent(slotIndex, k -> new TrafficSlotAgg()); agg.add(inputBps, outputBps); 
} 
  
// 결과 DTO 생성 (빈 슬롯 0 처리) 
List<DeviceTypeTrafficDTO> result = new ArrayList<>((int) totalSlots); 
for (long slotIndex = 0; slotIndex < totalSlots; slotIndex++) { 
  long slotTime = startUnix + slotIndex * intervalSecond; 
  long displayTime = slotTime + intervalSecond; 
  LocalDateTime dt = LocalDateTime.ofInstant( Instant.ofEpochSecond(displayTime), ZONE_SEOUL ); 
  TrafficSlotAgg agg = slotAggMap.get(slotIndex); 
  float avgInput = agg != null ? agg.avgInput() : 0f; 
  float avgOutput = agg != null ? agg.avgOutput() : 0f; 
  result.add(DeviceTypeTrafficDTO.of(avgInput, avgOutput, dt)); 
} 
return result;

// 쿼리
@Query( value = "SELECT " + " s.timestamp AS ts, " + " s.input_bps AS inputBps, " + " s.output_bps AS outputBps " 
  + "FROM sw_conf_ports_stat_c s " 
  + "JOIN sw_conf_total_switch sw " 
  + " ON s.mgmt_ip = sw.mgmt_ip " + " AND sw.school_mark IN (:schoolMarks) " + " AND sw.switch_role = 'SPINE' " + " AND sw.is_default = true " 
  + "JOIN sw_conf_link l " + " ON s.mgmt_ip = l.src_ip " + " AND s.port_index = l.src_port_index " + " AND l.src_port_type = 'UPLINK' " 
  + "WHERE s.timestamp BETWEEN :startDts AND :endDts " + " AND s.status = 'UP' " 
  + "ORDER BY s.timestamp", nativeQuery = true) 
List<Object[]> findTrafficRawRows( @Param("schoolMarks") Set<String> schoolMarks, @Param("startDts") String startDts, @Param("endDts") String endDts );

```

---

### 해결 방법
- 단일 쿼리 -> 1시간 짜리 분할 쿼리로 변경
  - BETWEEN start AND end 를 사용하여 6일이면 1,300만 row를 한 번에 반환하도록 했었음 -> 최대 6일이면 144번 쿼리 발생. 각 쿼리당 약 9만 row 반환
- 변경된 방식의 장점
  - DB 안정성 높아짐. 각 쿼리가 작아지고 예측 가능해졌고, 실행 계획 캐시를 활용할 수 있기 때문
  - 인덱스 효율이 높아짐: timestamp >= ? AND timestamp < ? → range scan 최적
  - 타임아웃이 제거됨
- 변경된 방식의 단점
  - 쿼리 횟수가 증가됨: 1회 -> 144회
  - 네트워크 왕복(RTT) 비용 증가됨
  - 메모리 사용량은 개선되지 않았음
    - 예상 메모리 사용량
      - Object[] (3컬럼) + Timestamp + Double
      - 보수적으로 1 row ≈ 80~100 bytes -> 13,000,000 × 100B ≈ 1.3GB
      - ❗ GC 압박은 여전히 매우 큼
  - cpu 사용량은 소폭 증가 : hashMap 대신 treeMap을 사용하고 Stream overhead, double boxing/unboxing 때문임
- **그래도 타임아웃을 해결했다는 큰 의미가 있음**

```java
// 서비스 코드
public List<DeviceTypeTrafficDTO> fetchFromRawStat( Set<String> schoolMarks, LocalDateTime startDts, LocalDateTime endDts, long intervalSecond) { 
    List<Object[]> allRawRows = new ArrayList<>(); 
    LocalDateTime currentStart = startDts; 
    
    // 1. 1시간 단위 분할 조회 (DB 타임아웃 방지) 
    while (currentStart.isBefore(endDts)) { 
        LocalDateTime currentEnd = currentStart.plusHours(1); 
        if (currentEnd.isAfter(endDts)) { currentEnd = endDts; } 
        
        // 쿼리 호출 (힌트 포함된 STRAIGHT_JOIN 쿼리) 
        List<Object[]> chunk = swConfPortsStatCRepository.findTrafficRawRows( schoolMarks, currentStart, currentEnd); 
        if (chunk != null) { allRawRows.addAll(chunk); } 
        currentStart = currentEnd; 
    } 
    
    // 2. 결과 맵 초기화 (데이터가 없어도 시간축을 보장하기 위함) 
    Map<Long, List<Object[]>> groupedByInterval = new TreeMap<>(); 
    // 정렬을 위해 TreeMap 사용 
    long startEpoch = startDts.atZone(ZoneId.systemDefault()).toEpochSecond(); 
    long endEpoch = endDts.atZone(ZoneId.systemDefault()).toEpochSecond(); 
    
    // 시작부터 종료까지 intervalSecond 단위로 빈 리스트를 미리 생성 
    for (long t = (startEpoch / intervalSecond) * intervalSecond; t < endEpoch; t += intervalSecond) { 
        groupedByInterval.put(t, new ArrayList<>()); 
    } 
    
    // 3. 수집된 데이터를 해당 시간 버킷에 분류 
    for (Object[] row : allRawRows) { 
        if (row[0] == null) continue; 
        long epochSecond = ((Timestamp) row[0]).getTime() / 1000; 
        long bucket = (epochSecond / intervalSecond) * intervalSecond; 
        
        // 미리 만들어둔 버킷에 데이터 추가 (범위 밖 데이터는 무시) 
        if (groupedByInterval.containsKey(bucket)) { 
            groupedByInterval.get(bucket).add(row); 
        } 
    } 
    
    // 4. 평균 계산 및 DTO 변환 
    return groupedByInterval.entrySet().stream() .map(entry -> { 
        long bucketTimestamp = entry.getKey(); 
        List<Object[]> bucketData = entry.getValue(); 
        double avgInput = 0.0; double avgOutput = 0.0; 
        if (!bucketData.isEmpty()) { 
            avgInput = bucketData.stream()
                .mapToDouble(r -> r[1] != null ? ((Number) r[1]).doubleValue() : 0.0) 
                .average().orElse(0.0); 
            avgOutput = bucketData.stream() 
                .mapToDouble(r -> r[2] != null ? ((Number) r[2]).doubleValue() : 0.0) 
                .average().orElse(0.0); 
        } 
        
        // DTO 생성 (LocalDateTime 변환 포함) 
        LocalDateTime ts = LocalDateTime.ofInstant( Instant.ofEpochSecond(bucketTimestamp), ZoneId.systemDefault()); 
        return DeviceTypeTrafficDTO.of( (float) avgInput, (float) avgOutput, ts); }) 
            .collect(Collectors.toList()); 
}

// 쿼리
@Query(value = "SELECT /*+ STRAIGHT_JOIN */ s.timestamp, s.input_bps, s.output_bps " 
  + "FROM sw_conf_total_switch sw " 
  + "INNER JOIN sw_conf_link l ON sw.mgmt_ip = l.src_ip " 
  + "INNER JOIN sw_conf_ports_stat_c s ON s.mgmt_ip = l.src_ip AND s.port_index = l.src_port_index " 
  + "WHERE s.timestamp >= :startDts AND s.timestamp < :endDts " 
  + " AND s.status = 'UP' " 
  + " AND sw.school_mark IN (:schoolMarks) " 
  + " AND sw.switch_role = 'SPINE' " 
  + " AND sw.is_default = true " 
  + " AND l.src_port_type = 'UPLINK'", nativeQuery = true) 
List<Object[]> findTrafficRawRows( @Param("schoolMarks") Set<String> schoolMarks, @Param("startDts") LocalDateTime startDts, @Param("endDts") LocalDateTime endDts );
```