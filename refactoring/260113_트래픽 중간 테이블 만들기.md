### 문제 상황
- 그라파나의 트래픽 데이터 조회 시 뜨지 않음. 조회 시간이 10초를 넘어서 DB 조회 Timeout 걸림
- 특히 최근 5분/최근 30분/최근 24시간/최근 7일/최근 30일 기준에서 최근 7일/최근 30일은 항상 데이터가 조회되지 않고 최근 24시간은 간헐적으로 그래프가 조회되지 않음
- 데이터 규모는 하루에 1백만 rows 생기고, 한 달 기준 3천만 rows 생기는 수준. 그러나 향후 대상 장비 및 학교가 많아지면 데이터가 더욱 많아질 가능성 있음
- 또한 향후 그라파나 기능을 확장하여 6개월 치 데이터 조회도 필요할 가능성이 있었음
- 슬롯으로 조회 / 스프링 서비스 단에서 어떻게 하는 방법으로 문제를 해결해보려고 했으나 실패
- 따라서 1일치 스위치/AP별 평균 트래픽을 저장하는 중간 테이블을 만들어 저장하고 7일/30일 조회 시 사용하는 것으로 해결
- 또한 중간 테이블을 사용한 로직으로 6개월 조회도 가능한지 확인하기 위해 더미데이터 만들어 테스트 중

---

### 해결 방법
```java
// 1일치 트래픽 데이터를 조회하는 sw_conf_ports_stat_d 중간 테이블 생성
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "sw_conf_ports_stat_d", indexes = {
        @Index(name = "idx_d_mgmt_timestamp", columnList = "mgmt_ip, `timestamp`"),
        @Index(name = "idx_d_full_search", columnList = "mgmt_ip, port_index, `timestamp` DESC")})
@IdClass(SwConfPortsStatDId.class)
public class SwConfPortsStatD {
    // ... 중략

    @Id
    @Column(name = "timestamp", nullable = false)
    LocalDateTime timestamp;  // 1일치 통계 수집 시점

    // 1일치 트래픽 통계 컬럼 추가 및 수정
    @Column(name = "max_input_bps", nullable = true)
    Long maxInputBps;

    @Column(name = "max_output_bps", nullable = true)
    Long maxOutputBps;

    @Column(name = "avg_input_bps")
    Long avgInputBps;

    @Column(name = "avg_output_bps")
    Long avgOutputBps;
}

// 7일 이상 데이터 조회할 때는 중간 테이블에서 데이터를 조회 + 슬롯 분할하여 api 응답
public List<DeviceTypeTrafficDTO> fetchLinkSpeedTrafficDtos(Set<String> schoolMarks, LocalDateTime startDts, LocalDateTime endDts, long intervalSecond) {
    // 7~12일 → 일별 축
    if (days <= 15) {
        return fetchDailyByDay(schoolMarks, startDts, endDts);
    }
}

private List<DeviceTypeTrafficDTO> fetchDailyByDay(Set<String> schoolMarks, LocalDateTime startDts, LocalDateTime endDts) {
    // 1️⃣ DB 조회
    List<Object[]> rows = swConfPortsStatDRepository.findDailyTraffic(schoolMarks, startDts, endDts);

    // 2️⃣ 날짜 → 값 Map
    Map<LocalDate, TrafficAvg> valueMap = new HashMap<>();

    for (Object[] r : rows) {
        LocalDate day = ((Timestamp) r[0]).toLocalDateTime().toLocalDate();
        float in  = r[1] != null ? ((Number) r[1]).floatValue() : 0f;
        float out = r[2] != null ? ((Number) r[2]).floatValue() : 0f;
        valueMap.put(day, new TrafficAvg(in, out));
    }

    // 3️⃣ 전체 날짜 축 생성 + 0 처리
    List<DeviceTypeTrafficDTO> result = new ArrayList<>();

    LocalDate cur = startDts.toLocalDate();
    LocalDate end = endDts.toLocalDate();

    while (cur.isBefore(end)) {
        TrafficAvg avg = valueMap.get(cur);
        result.add(DeviceTypeTrafficDTO.of(
            avg != null ? avg.getInput() : 0f,
            avg != null ? avg.getOutput() : 0f,
            cur.atStartOfDay()
        ));
        cur = cur.plusDays(1);
    }
    return result;
}

// 주기적으로 중간 테이블에 데이터 넣어주는 스케줄러 등록
@Component
@RequiredArgsConstructor
@Slf4j
public class PortsStatDScheduler {

    private static final ZoneId ZONE_SEOUL = ZoneId.of("Asia/Seoul");

    private final FrontBuildLoaderService frontBuildLoaderService;
    private final MasterCheckService masterCheckService;

    private final PortsStatDService portsStatDService;

    /**
     * 매일 00시
     * 전날 포트 트래픽(C 테이블) → 일 단위 집계(D 테이블)
     */
    @Scheduled(cron = "0 0 0 * * *", zone = "Asia/Seoul")
    public void scheduleSavePortsStatDaily() {
        if (frontBuildLoaderService.getBuildType() != BuildType.JEONNAM
                && !masterCheckService.isMaster()) {
            return;
        }

        // 전날 날짜 계산
        LocalDate yesterday = LocalDate.now(ZONE_SEOUL).minusDays(1);

        LocalDateTime startDts = yesterday.atStartOfDay();
        LocalDateTime endDts = yesterday.plusDays(1).atStartOfDay();

        log.info("[PortsStatD] Daily aggregation start: {} ~ {}", startDts, endDts);

        try {
            portsStatDService.aggregateDailyPortsStat(startDts, endDts);
        } catch (Exception e) {
            log.error("[PortsStatD] Daily aggregation failed", e);
        }
    }
}

```

---

### 시도 방법
```java
// 스프링 서비스 단에서 슬롯 분할하여 api 응답 > 그러나 데이터 개수가 너무 많아서 소용 없었음
public List<DeviceTypeTrafficDTO> fetchFromRawStat(Set<String> schoolMarks, LocalDateTime startDts, LocalDateTime endDts, long intervalSecond) {
        // ... 중략
        // Raw 데이터 조회
        List<Object[]> rows = swConfPortsStatCRepository.findTrafficRawRows(schoolMarks, startDts.format(formatter), endDts.format(formatter));

        // slotIndex → 누적 구조
        Map<Long, TrafficSlotAgg> slotAggMap = new HashMap<>();

        for (Object[] row : rows) {
            Timestamp ts = (Timestamp) row[0];
            float inputBps = row[1] != null ? ((Number) row[1]).floatValue() : 0f;
            float outputBps = row[2] != null ? ((Number) row[2]).floatValue() : 0f;

            long tsUnix = ts.toInstant().getEpochSecond();
            long slotIndex = (tsUnix - startUnix) / intervalSecond;

            if (slotIndex < 0 || slotIndex >= totalSlots) {
                continue;
            }

            TrafficSlotAgg agg = slotAggMap.computeIfAbsent(slotIndex, k -> new TrafficSlotAgg());
            agg.add(inputBps, outputBps);
        }

        // 결과 DTO 생성 (빈 슬롯 0 처리)
        List<DeviceTypeTrafficDTO> result = new ArrayList<>((int) totalSlots);

        for (long slotIndex = 0; slotIndex < totalSlots; slotIndex++) {

            long slotTime = startUnix + slotIndex * intervalSecond;
            long displayTime = slotTime + intervalSecond;

            LocalDateTime dt = LocalDateTime.ofInstant(
                Instant.ofEpochSecond(displayTime),
                ZONE_SEOUL
            );

            TrafficSlotAgg agg = slotAggMap.get(slotIndex);
            float avgInput = agg != null ? agg.avgInput() : 0f;
            float avgOutput = agg != null ? agg.avgOutput() : 0f;

            result.add(DeviceTypeTrafficDTO.of(avgInput, avgOutput, dt));
        }

        return result;
    }

@Query(value = "SELECT `timestamp` AS dateTime, AVG(input_bps)  AS recvBps, AVG(output_bps) AS sendBps "
            + "FROM sw_conf_ports_stat_c " + "WHERE mgmt_ip = :mgmtIp AND `timestamp` >= :fromDateTime "
            + "GROUP BY DATE(`timestamp`) " + "ORDER BY DATE(`timestamp`) ASC", nativeQuery = true)
    List<DailyTrafficProjection> findDailyTrafficByMgmtIp(@Param("mgmtIp") String mgmtIp,
            @Param("fromDateTime") LocalDateTime fromDateTime);
```